/*
https://www.youtube.com/watch?v=egoMqpY2myQ 
4:11:23 

Оптимизация:
    Реализация fibonacci без блокировки

    дополняем hash / map
*/


setTimeout(
    ()=>console.log('Timeout'), 0
)


const cache = new Map()

// необходим оптимальный алгоритм чтобы найти все цифры
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
function fib(n){

    return new Promise(
        (resolve, reject) =>{
            if (n === 0 || n ===1){
                return resolve(n)
            }
        
        
        if (cache.has(n)){
           return resolve(cache.get(n))
        }

           setImmediate(
            () => 
                Promise.all([fib(n-1), fib(n-2)])
                    .then(([fib1, fib2]) => {

                        //сохраняем в паре: key + value
                        cache.set(n, fib1+fib2)
                        resolve(fib1 + fib2)
                    })
           )
        }
    )
}


fib(40).then(
    (res) => console.log(res)
)

/* code ran successfully but took time
Output:
Timeout
102334155

*/
// console.log(cache.size)


/*
Этот код реализует асинхронную версию вычисления чисел Фибоначчи с кэшированием результатов. Давайте разберем его по частям:
1. Создание кэша:

const cache = new Map()

Здесь создается объект Map, который будет использоваться для кэширования уже вычисленных значений чисел Фибоначчи. Это позволяет избежать повторных вычислений, ускоряя выполнение алгоритма, особенно для больших значений.
2. Функция fib:

function fib(n){
    return new Promise(
        (resolve, reject) => {
            if (n === 0 || n === 1){
                return resolve(n)
            }

Функция fib принимает число n и возвращает промис, который будет разрешен с результатом вычисления n-го числа Фибоначчи. Если n равно 0 или 1 (базовые случаи), то сразу возвращается n (числа Фибоначчи для 0 и 1 известны — 0 и 1 соответственно).
3. Проверка наличия числа в кэше:

if (cache.has(n)){
   return resolve(cache.get(n))
}

Перед тем как вычислять значение числа Фибоначчи, функция проверяет, есть ли уже результат для n в кэше. Если есть, то сразу возвращается сохраненное значение, чтобы избежать лишних вычислений.
4. Асинхронное вычисление:

setImmediate(
    () => 
        Promise.all([fib(n-1), fib(n-2)])
            .then(([fib1, fib2]) => {

                //сохраняем в паре: key + value
                cache.set(n, fib1 + fib2)
                resolve(fib1 + fib2)
            })
)

Если значения для n нет в кэше, происходит асинхронное вычисление чисел Фибоначчи для n-1 и n-2. Для этого используется Promise.all(), чтобы параллельно вычислить оба значения.

    setImmediate() используется, чтобы поставить выполнение этой асинхронной операции в очередь, позволяя другим операциям завершиться перед этим.
    Когда оба числа Фибоначчи вычислены (через fib(n-1) и fib(n-2)), результат их суммы кэшируется и возвращается в промис.

5. Инициация вычисления для fib(40):

fib(40).then(
    (res) => console.log(res)
)

Здесь вызывается fib(40), и когда вычисление завершится (с помощью промиса), результат выводится в консоль.
Общее описание работы:

    При вызове fib(n) выполняется проверка: если значение уже вычислено (оно есть в кэше), оно возвращается. Это ускоряет выполнение для уже известных значений.
    Если значение еще не вычислено, то запускается асинхронный расчет для чисел Фибоначчи для n-1 и n-2. Они вычисляются параллельно с помощью Promise.all.
    После вычисления чисел сохраняется их сумма в кэш, чтобы в дальнейшем не повторять вычисление для того же n.
    Благодаря setImmediate выполнение отложенных вычислений происходит в следующем цикле событий, что позволяет не блокировать основной поток выполнения программы.

Почему этот алгоритм эффективен?

    Кэширование (Memoization): используется для хранения уже вычисленных значений чисел Фибоначчи, что предотвращает многократные вычисления одинаковых значений. Это значительно ускоряет выполнение, особенно для больших значений n.
    Асинхронность: с использованием промисов и setImmediate обеспечивается асинхронная природа вычислений, позволяющая не блокировать основной поток и эффективно работать с большими числами.

Пояснение по производительности:

Хотя этот алгоритм использует рекурсию, из-за кэширования каждый результат вычисляется только один раз, что значительно снижает количество операций для больших чисел.


*/

/*
Да, результаты вычислений не остаются в Map после завершения выполнения программы, потому что объект Map в данном случае является локальной переменной внутри выполнения кода, а не глобальной или долгоживущей переменной.

Давайте разберем подробнее, почему так происходит:
1. Область видимости и жизненный цикл переменной cache:

Переменная cache объявляется внутри файла (или функции), и её область видимости ограничена этим контекстом. Когда весь код завершает выполнение, память, занимаемая этим объектом Map, освобождается, и объект уничтожается.

В вашем случае, после завершения работы программы, объект cache и его данные стираются. Это происходит, потому что сам объект cache не сохраняется в глобальном состоянии программы.
2. Асинхронность и работа с промисами:

Как только все промисы в fib(40) разрешены и выполнение завершается, объект cache теряет свою актуальность и будет очищен, если в коде нет другой ссылки на него, которая могла бы сохранить его состояние.
Как это можно исправить?

Чтобы сохранить кэш после выполнения программы, необходимо:

    Сделать cache глобальной переменной, или
    Сохранить его в другой долгоживущей структуре данных, например, в localStorage (если нужно сохранять данные на клиенте) или в базе данных (если требуется сохранить кэш между сессиями).


*/