const http = require('http')
const EventEmitter = require('events')

module.exports = class Application{
    constructor(){
        this.emitter = new EventEmitter
        //не будем создавать через createServer
        //сделаем через метод класса 1:30:28
        this.server = this._createServer()
        //1:38:54, adding middlewares to array
        this.middlewares =[]
    }

    use(middleware){
        this.middlewares.push(middleware)

    }

    //отработает тогда когда сервер запустился
    listen(port, callback){
        this.server.listen(port, callback)
    }

    //Зачем он так сделал?
    //_ means the method is private and should not be used outside
    _createServer(){
        return http.createServer((req, res) =>{
            /*1:41:44 
            Для post запроса от клиента нужно req stream прочитать

            */

            let body = ""
            //data - данные для передачи
            req.on('data', (chunk) =>{
                 console.log(chunk)
                 body += chunk // считаем весь запрос в один файл
            })
            /*
                output: 
                <Buffer 7b 0a 20 ...>
                получем Buffer от клиента (в Postman сделали post зaпрос от клиента:
                отправили  JSON object {
                "name":"Baatr"
                }
            )
            */

            //end -это конец чтения
            req.on('end', (chunk) =>{
                //все что пришло парсим в строку и сохраняем
                if(body){
                    req.body = JSON.parse(body)
                }

            /*
                1:46:44 adding middleware array not before handler 
                (бежим по массиву и вызываем функции, переводим данные в JSON)
                The assumption is that the middlewares are modifying 
                the request or response in some way, such as converting 
                data into JSON format.

                
            */
                this.middlewares.forEach(middleware => middleware(req,res))


            //эмитим события, которые прописали в логике по названию 
            //события, то есть по шаблону события: 
            //`[${path}]:[${method}]`
            //параметры такие же как в функции emitter.on(`[${path}]:[${method}]`, (req, res)
            //this. added to emitter, the mask is decided to move to different function
            //the function can be reused

            //передвинули middleware непосредственно перед генерацией события,
            // a не перед хандлером, чтобы Pathname уже был доступен
            //changed from req.url req.pathname
            // console.log(req.pathname) // /users 
            const emitted = 
            this.emitter.emit(this._getRouteMask(req.pathname,req.method), req, res)
            
            //если неизвестный url, то закрываем поток, 
            //чтобы он не висел
            //endpoints work normally
            if(!emitted){
                res.end()
            }
            })

            
            

        })
    }

    //private function again: вынесли сюда маску
    _getRouteMask(path, method){
        return `[${path}]:[${method}]`
    }


    /*
        The object endpoints has this structure:
            endpoints = {
                        '/users':   {
                                    'GET': handler1, 
                                    'POST': handler2, 
                                    'DELETE": handler3
                                    }
                        }
    */

    /*
        В вашем коде использование forEach для обхода ключей объекта имеет смысл, 
        даже если для каждого ключа есть только одно значение, по следующим причинам:

        Гибкость и масштабируемость: Возможно, в будущем в объекте будет несколько значений для каждого ключа, 
        или структура объекта может измениться (например, можно добавить дополнительные методы HTTP). 
        Использование forEach позволяет работать с любыми данными, даже если структура объекта будет изменяться. 
        Так что, хотя на данный момент для каждого ключа может быть только один обработчик, 
        использование forEach даёт гибкость для будущих изменений.

        Работа с динамическими данными: В реальных приложениях структура маршрутов может меняться динамически 
        (например, маршруты могут добавляться или изменяться во время работы программы). 
        Пробежав по всем ключам с помощью forEach, вы гарантируете, что обрабатываете все текущие маршруты,
        независимо от того, сколько их и как они добавляются.

        Масштабируемость к дополнительным методам или маршрутам: 
        Если в будущем появятся дополнительные маршруты или HTTP-методы, использование 
        forEach позволит вам легко адаптировать код для обработки новых значений, 
        без необходимости менять логику вручную для каждого конкретного маршрута.
        
    */




    addRouter(router){
        // Обрабатываем все маршруты (например, '/users')
        Object.keys(router.endpoints).forEach(path =>{
            const endpoint = router.endpoints[path]// Получаем объект, содержащий методы (GET, POST, DELETE)
           
            //Обрабатываем все методы для текущего маршрута (например, 'GET', 'POST', 'DELETE')
            Object.keys(endpoint).forEach(method =>{
                const handler = endpoint[method] // Получаем обработчик для метода
                    this.emitter.on(this._getRouteMask(path, method), (req, res) => {

                    
                    //внутри события используем handler с двумя стримами
                    //принимаем от пользователя запрос и отправляем ответ
                    //Вызов обработчика для текущего метода маршрута
                    handler(req, res)
                    //теперь можно использовать класс Router внутри класса Application
                })
            })
        })
    }
}

/*
    Отличная аналогия! Сравнение с кодовым замком действительно 
    прекрасно передает суть работы этого кода.

    Давайте разберем, как она работает в контексте вашего кода:

    Колеса замка (маршруты и методы): Представьте, что у нас есть несколько колес, 
    и каждое из них может быть настроено на определенное значение. В вашем случае эти 
    "колеса" — это маршруты и методы. Каждый маршрут (например, '/users') — это как первое колесо, 
    а методы для этого маршрута (например, GET, POST, DELETE) — это как следующее колесо, 
    которое зависит от того, какой маршрут вы выбрали.

    Выбор значений (обработчики): Когда вы "крутите" каждое колесо (выбираете путь и метод), 
    вы устанавливаете соответствующие обработчики. Это похоже на то, как вы подбираете 
    правильные значения в кодовом замке — выбор правильного значения на каждом колесе 
    открывает доступ к следующему.

    Поиск правильной комбинации (сопоставление значений): Когда приходит запрос с определенным 
    путем и методом, система перебирает "колеса" (первый путь, затем метод) и пытается подобрать 
    соответствующие обработчики. Каждый шаг — это как поворот колеса, где вы выбираете правильное 
    значение, чтобы двигаться дальше. Когда правильно выбраны все значения (маршрут и метод), 
    система открывает доступ к нужному обработчику.

    Таким образом, процесс работы с кодом можно представить как набор шагов для правильного 
    набора комбинации кодового замка. Вы идете по порядку, крутите колесо маршрута, 
    затем — метод, и когда комбинация совпадает, срабатывает нужный обработчик.

    Это хорошее и четкое представление, которое помогает понять, как система обрабатывает 
    запросы, проверяя каждый элемент маршрута и метода поочередно, 
    пока не "откроет" нужный обработчик.

*/



